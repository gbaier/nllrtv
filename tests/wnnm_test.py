import numpy as np
import pytest

from nllrtv import wnnm
from nllrtv import util

# testing accuracy
DECIMAL = 3

# Test parameterization taken from experiment in
# E. Candes, "Robust principal component analysis?", 2009
# dimension, rank, number of outliers
TEST_PARAMS = [
    (100, 5, 500),
    #(200, 10, 2000),
    # (500, 25, 12500),
    # (1000,  50,  50000),
    # (2000, 100, 200000),
    # (3000, 250, 450000),
]


def lowrank_square_normal(size, rank, std=1.0):
    """ generates a square low rank matrix

    The matrix is generated by multiplying two normally distributed
    matrices.

    Parameters:

    :param size: integer
        the returned matrix will be of shape (size, size)
    :param rank: integer
        rank of the returned matrix
    :param std: float
        the normall distributed matrices' standard deviation

    """

    # scale expects standard deviation
    X = np.random.normal(scale=std, size=(size, rank))
    Y = np.random.normal(scale=std, size=(rank, size))

    return X @ Y


@pytest.mark.parametrize("size, rank, n_outlier", TEST_PARAMS)
def test_rcpa(size, rank, n_outlier):
    """testing robust principal component analysis
    reproducing experiments from the paper.

    """

    # low rank matrix
    L = lowrank_square_normal(size, rank, np.sqrt(1.0 / size))

    # sparse outliers
    p_outlier = n_outlier / L.size
    S = np.random.choice(
        [-1.0, 0.0, 1.0], p=[p_outlier / 2, 1 - p_outlier, p_outlier / 2], size=L.shape
    )

    M = L + S
    L_est, S_est = wnnm.rpca(M)

    np.testing.assert_array_almost_equal(S, S_est, decimal=DECIMAL)
    np.testing.assert_array_almost_equal(L, L_est, decimal=DECIMAL)
    assert np.linalg.matrix_rank(L_est) == rank


@pytest.mark.parametrize("size, rank, n_outlier", TEST_PARAMS)
def test_rcpa_wnnm(size, rank, n_outlier):
    """ checks that for a uniform weighting vector the result
    is identical to regular robust PCA
    """

    # low rank matrix
    L = lowrank_square_normal(size, rank, np.sqrt(1.0 / size))

    # sparse outliers
    p_outlier = n_outlier / L.size
    S = np.random.choice(
        [-1, 0, 1], p=[p_outlier / 2, 1 - p_outlier, p_outlier / 2], size=L.shape
    )
    S = S.astype(np.float)

    M = L + S

    # check rcpa code
    lbda = 1 / np.sqrt(np.max(M.shape))
    mu = np.prod(M.shape) / (4 * np.sum(np.abs(M)))
    w = np.ones(np.min(M.shape)) / lbda

    L_est_wei, S_est_wei = wnnm.rpca_wnnm(M, w, mu, max_iter=100)
    L_est, S_est = wnnm.rpca(M, max_iter=100)

    np.testing.assert_array_almost_equal(S_est_wei, S_est, decimal=DECIMAL)
    np.testing.assert_array_almost_equal(L_est_wei, L_est, decimal=DECIMAL)


def test_mat_comp():
    size = 250
    rank = 3
    ratio_samples = 0.24

    # Taken from the respective publication. There it was only applied to square matrices.
    tau = 5 * size

    L = lowrank_square_normal(size, rank)

    n_samples = int(ratio_samples * L.size)
    mask = np.zeros(L.shape, dtype=np.bool)
    for coord in util.random_coords(L.shape, n_samples):
        mask[coord] = True

    L_obs = np.zeros_like(L)
    L_obs[mask] = L[mask]

    L_est = wnnm.mat_comp(L_obs, mask, tau, max_iter=250, eps=1e-4)

    np.testing.assert_array_almost_equal(L_est, L, 2)


@pytest.mark.parametrize("size, rank, n_outlier", TEST_PARAMS)
def test_wnnm_rcpa_tv_notv(size, rank, n_outlier):
    """ checks that for a uniform weighting vector and disabled TV
    regularization the result is identical to regular robust PCA
    """

    # low rank matrix
    L = lowrank_square_normal(size, rank, np.sqrt(1.0 / size))

    # sparse outliers
    p_outlier = n_outlier / L.size
    S = np.random.choice(
        [-1, 0, 1], p=[p_outlier / 2, 1 - p_outlier, p_outlier / 2], size=L.shape
    )
    S = S.astype(np.float)

    M = L + S

    # check rcpa code
    lbda = 1 / np.sqrt(np.max(M.shape))
    # Lagrange multiplier
    alpha = np.prod(M.shape) / (4 * np.sum(np.abs(M)))
    w = np.ones(np.min(M.shape)) / lbda

    params = {
        "lbda": 0.0001,  # image TV regularization
        "mu": 1,
        "nu": 0.001,  # speckle TV regularization
        "alpha": alpha,
        "beta": 50.0,
        "gamma": 50.0,
        "max_iter": 200,
        "axes": (1,),
    }

    L_est_wei, S_est_wei, N_est_wei = wnnm.rpca_wnnm_tv(M, w, **params)
    L_est, S_est = wnnm.rpca(M, max_iter=params["max_iter"])

    np.testing.assert_array_almost_equal(S_est_wei + N_est_wei, S_est, decimal=DECIMAL)
    np.testing.assert_array_almost_equal(L_est_wei, L_est, decimal=DECIMAL)
